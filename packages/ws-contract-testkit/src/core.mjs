/**
 * @typedef {object} EventContract
 * @property {string} subject
 * @property {string} subject_pattern
 * @property {boolean} supports_scoped_suffix
 * @property {string} payload_type
 * @property {Record<string, unknown>} payload_schema
 */

/**
 * @typedef {object} ContractIndex
 * @property {Map<string, EventContract>} exactContracts
 * @property {EventContract[]} scopedContracts
 */

/**
 * @param {unknown} value
 * @returns {string}
 */
export function toCanonicalJson(value) {
	return `${JSON.stringify(value, null, 2)}\n`;
}

/**
 * @param {unknown} catalog
 * @returns {ContractIndex}
 */
export function createContractIndex(catalog) {
	const events = Array.isArray(catalog?.events) ? catalog.events : [];
	const exactContracts = new Map(events.map((contract) => [contract.subject, contract]));
	const scopedContracts = events
		.filter((contract) => contract.supports_scoped_suffix)
		.sort((a, b) => b.subject.length - a.subject.length);

	return {
		exactContracts,
		scopedContracts
	};
}

/**
 * @param {ContractIndex} index
 * @param {string} subject
 * @returns {EventContract | null}
 */
export function findExactEventContract(index, subject) {
	return index.exactContracts.get(subject) ?? null;
}

/**
 * @param {EventContract} contract
 * @param {string} subject
 * @returns {boolean}
 */
export function subjectMatchesContract(contract, subject) {
	if (subject === contract.subject) {
		return true;
	}

	return contract.supports_scoped_suffix && subject.startsWith(`${contract.subject}.`);
}

/**
 * @param {ContractIndex} index
 * @param {string} subject
 * @returns {EventContract | null}
 */
export function findEventContract(index, subject) {
	const exact = findExactEventContract(index, subject);
	if (exact) {
		return exact;
	}

	for (const contract of index.scopedContracts) {
		if (subject.startsWith(`${contract.subject}.`)) {
			return contract;
		}
	}

	return null;
}

/**
 * @param {string} subject
 * @param {string | undefined | null} subjectId
 * @param {readonly string[]} placeholders
 * @returns {{ok: true, value: string} | {ok: false, error: string}}
 */
export function resolveSubject(subject, subjectId, placeholders = ['{scope_id}', '{scope}']) {
	if (!isNonEmptyString(subject)) {
		return {
			ok: false,
			error: 'subject must be a non-empty string'
		};
	}

	let resolved = subject;
	const usesPlaceholder = placeholders.some((placeholder) => resolved.includes(placeholder));
	if (usesPlaceholder) {
		if (!isNonEmptyString(subjectId)) {
			return {
				ok: false,
				error: `subject "${subject}" uses placeholder but no subject_id was provided`
			};
		}
		for (const placeholder of placeholders) {
			resolved = resolved.replaceAll(placeholder, subjectId);
		}
	}

	if (resolved.includes('{')) {
		return {
			ok: false,
			error: `subject "${subject}" has unresolved placeholder(s): "${resolved}"`
		};
	}

	return { ok: true, value: resolved };
}

/**
 * @param {EventContract} contract
 * @param {unknown} payloadOverrides
 * @returns {unknown}
 */
export function buildPayloadFromContract(contract, payloadOverrides) {
	const basePayload = createPayloadFromSchema(contract.payload_schema, '$');
	if (payloadOverrides === undefined) {
		return basePayload;
	}
	return deepMerge(basePayload, payloadOverrides);
}

/**
 * @param {unknown} schema
 * @param {unknown} value
 * @returns {string[]}
 */
export function validatePayloadWithSchema(schema, value) {
	const errors = [];
	validateSchema(schema, value, '$', errors);
	return errors;
}

/**
 * @param {ContractIndex} index
 * @param {string} subject
 * @param {unknown} payload
 */
export function validatePayloadAgainstContract(index, subject, payload) {
	const contract = findEventContract(index, subject);
	if (!contract) {
		throw new Error(`No event contract found for subject "${subject}"`);
	}

	const errors = validatePayloadWithSchema(contract.payload_schema, payload);
	if (errors.length > 0) {
		const topErrors = errors.slice(0, 8).join('\n- ');
		throw new Error(
			`Payload contract validation failed for "${subject}" (${contract.payload_type}):\n- ${topErrors}`
		);
	}
}

/**
 * @param {unknown} contractCatalog
 * @param {{sourceName?: string}} options
 * @returns {string}
 */
export function renderContractCatalogTsModule(contractCatalog, options = {}) {
	const sourceName = options.sourceName ?? 'ws-contract-testkit';

	return `// Auto-generated by ${sourceName}. Do not edit manually.\n\nexport type ContractActor = {\n  service: string;\n  module: string;\n};\n\nexport type EventContract = {\n  subject: string;\n  subject_pattern: string;\n  supports_scoped_suffix: boolean;\n  summary?: string;\n  description?: string;\n  producer: ContractActor;\n  consumers?: ContractActor[];\n  payload_type: string;\n  payload_schema: Record<string, unknown>;\n};\n\nexport type EventContractCatalog = {\n  version: string;\n  generated_at: string;\n  events: EventContract[];\n};\n\nexport const EVENT_CONTRACT_CATALOG: EventContractCatalog = ${JSON.stringify(contractCatalog, null, 2)} as EventContractCatalog;\nexport const EVENT_CONTRACTS: EventContract[] = EVENT_CONTRACT_CATALOG.events;\n`;
}

/**
 * @param {unknown} schema
 * @param {string} pathLabel
 * @returns {unknown}
 */
function createPayloadFromSchema(schema, pathLabel) {
	if (!isObject(schema)) {
		return null;
	}

	if ('const' in schema) {
		return schema.const;
	}

	if (Array.isArray(schema.enum) && schema.enum.length > 0) {
		return schema.enum[0];
	}

	if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
		return createPayloadFromSchema(schema.anyOf[0], pathLabel);
	}

	if (Array.isArray(schema.oneOf) && schema.oneOf.length > 0) {
		return createPayloadFromSchema(schema.oneOf[0], pathLabel);
	}

	if (Array.isArray(schema.allOf) && schema.allOf.length > 0) {
		return schema.allOf.reduce((acc, entry) => {
			const next = createPayloadFromSchema(entry, pathLabel);
			if (isObject(acc) && isObject(next)) {
				return deepMerge(acc, next);
			}
			return next;
		}, {});
	}

	const schemaType = typeof schema.type === 'string' ? schema.type : undefined;
	switch (schemaType) {
		case 'object':
			return buildObjectPayload(schema, pathLabel);
		case 'array':
			return buildArrayPayload(schema, pathLabel);
		case 'string':
			return buildStringPayload(schema, pathLabel);
		case 'boolean':
			return false;
		case 'integer':
		case 'number':
			return 0;
		case 'null':
			return null;
		default:
			if (isObject(schema.properties)) {
				return buildObjectPayload(schema, pathLabel);
			}
			return null;
	}
}

/**
 * @param {Record<string, unknown>} schema
 * @param {string} pathLabel
 * @returns {Record<string, unknown>}
 */
function buildObjectPayload(schema, pathLabel) {
	const properties = isObject(schema.properties) ? schema.properties : {};
	const required = Array.isArray(schema.required)
		? schema.required.filter((key) => typeof key === 'string')
		: [];

	return required.reduce((acc, key) => {
		acc[key] = createPayloadFromSchema(properties[key], `${pathLabel}.${key}`);
		return acc;
	}, {});
}

/**
 * @param {Record<string, unknown>} schema
 * @param {string} pathLabel
 * @returns {unknown[]}
 */
function buildArrayPayload(schema, pathLabel) {
	const minItems = Number.isInteger(schema.minItems) ? schema.minItems : 0;
	if (minItems <= 0) {
		return [];
	}

	return Array.from({ length: minItems }, () =>
		createPayloadFromSchema(schema.items, `${pathLabel}[]`)
	);
}

/**
 * @param {Record<string, unknown>} schema
 * @param {string} pathLabel
 * @returns {string}
 */
function buildStringPayload(schema, pathLabel) {
	if (schema.format === 'date-time') {
		return '2026-01-01T00:00:00Z';
	}
	if (schema.format === 'email') {
		return 'test@example.com';
	}
	if (schema.format === 'uuid') {
		return '00000000-0000-4000-8000-000000000000';
	}
	if (pathLabel.toLowerCase().includes('id')) {
		return 'id-1';
	}
	return 'string';
}

/**
 * @param {unknown} base
 * @param {unknown} override
 * @returns {unknown}
 */
function deepMerge(base, override) {
	if (Array.isArray(base) && Array.isArray(override)) {
		return override;
	}

	if (isObject(base) && isObject(override)) {
		const merged = { ...base };
		for (const [key, value] of Object.entries(override)) {
			merged[key] = key in merged ? deepMerge(merged[key], value) : value;
		}
		return merged;
	}

	return override;
}

/**
 * @param {unknown} schema
 * @param {unknown} value
 * @param {string} pathLabel
 * @param {string[]} errors
 */
function validateSchema(schema, value, pathLabel, errors) {
	if (!isObject(schema) || Object.keys(schema).length === 0) {
		return;
	}

	const schemaType = typeof schema.type === 'string' ? schema.type : undefined;
	switch (schemaType) {
		case 'object':
			validateObjectSchema(schema, value, pathLabel, errors);
			break;
		case 'array':
			validateArraySchema(schema, value, pathLabel, errors);
			break;
		case 'string':
			if (typeof value !== 'string') errors.push(`${pathLabel} expected string`);
			break;
		case 'boolean':
			if (typeof value !== 'boolean') errors.push(`${pathLabel} expected boolean`);
			break;
		case 'integer':
			if (!Number.isInteger(value)) errors.push(`${pathLabel} expected integer`);
			break;
		case 'number':
			if (typeof value !== 'number') errors.push(`${pathLabel} expected number`);
			break;
		default:
			break;
	}
}

/**
 * @param {Record<string, unknown>} schema
 * @param {unknown} value
 * @param {string} pathLabel
 * @param {string[]} errors
 */
function validateObjectSchema(schema, value, pathLabel, errors) {
	if (!isObject(value)) {
		errors.push(`${pathLabel} expected object`);
		return;
	}

	const required = Array.isArray(schema.required) ? schema.required : [];
	for (const key of required) {
		if (typeof key !== 'string') {
			continue;
		}
		if (!(key in value)) {
			errors.push(`${pathLabel}.${key} is required`);
		}
	}

	const properties = isObject(schema.properties) ? schema.properties : {};
	for (const [key, childSchema] of Object.entries(properties)) {
		if (key in value) {
			validateSchema(childSchema, value[key], `${pathLabel}.${key}`, errors);
		}
	}

	if (schema.additionalProperties === false) {
		for (const key of Object.keys(value)) {
			if (!(key in properties)) {
				errors.push(`${pathLabel}.${key} is not allowed`);
			}
		}
	}
}

/**
 * @param {Record<string, unknown>} schema
 * @param {unknown} value
 * @param {string} pathLabel
 * @param {string[]} errors
 */
function validateArraySchema(schema, value, pathLabel, errors) {
	if (!Array.isArray(value)) {
		errors.push(`${pathLabel} expected array`);
		return;
	}

	const itemSchema = schema.items;
	if (!itemSchema) {
		return;
	}

	value.forEach((entry, index) => {
		validateSchema(itemSchema, entry, `${pathLabel}[${index}]`, errors);
	});
}

/**
 * @param {unknown} value
 * @returns {value is Record<string, unknown>}
 */
function isObject(value) {
	return typeof value === 'object' && value !== null && !Array.isArray(value);
}

/**
 * @param {unknown} value
 * @returns {value is string}
 */
function isNonEmptyString(value) {
	return typeof value === 'string' && value.trim().length > 0;
}
